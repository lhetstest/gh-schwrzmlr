#Function with datatypes defined in the definition
def add_numbers(num1: int, num2: int) -> int:
    sum = num1 + num2
    return sum

result = add_numbers(5, 10)
print(result)  # Виведе: 15

# function will return a string
def greet(name: str) -> str:
    return f"Привіт, {name}!"

greeting = greet("Олексій")
print(greeting)  # Виведе: Привіт, Олексій!

# function will return boolean value
def is_even(num: int) -> bool:
    return num % 2 == 0

check_even = is_even(4)
print(check_even)  # Виведе: True

"""
Принципи змінності об'єктів у Python
У Python об'єкти можуть бути змінними (mutable) або незмінними (immutable). Змінні об'єкти можна змінювати після їх створення, - int, float, str, tuple, frozenset, bytes, bool, NoneType є незмінними об'єктами, тоді як list, dict, set є змінними об'єктами. Змінні об'єкти можуть бути змінені після створення, тоді як незмінні об'єкти не можуть бути змінені після створення. Змінні об'єкти можуть бути змінені без створення нового об'єкта, тоді як незмінні об'єкти вимагають створення нового об'єкта при зміні значення. Змінні об'єкти можуть бути використані для зберігання даних, які можуть змінюватися, тоді як незмінні об'єкти можуть бути використані для зберігання даних, які не повинні змінюватися.
"""
def modify_string(original: str) -> str:
    original = "змінено"
    return original

str_var = "оригінал"
print(modify_string(str_var))  # виведе: змінено
print(str_var)                 # виведе: оригінал

# у цьому приклади навіть після заміни рядка в функції modify_string, змінна str_var залишається незмінною.
#Приклад зі змінними типами даних
def modify_list(lst: list) -> None:
    lst.append(4)

my_list = [1, 2, 3]
modify_list(my_list)
print(my_list)  # виведе: [1, 2, 3, 4]
# у цьому прикладі після виклику функції modify_list, змінна my_list була змінена, оскільки list є змінним типом даних.

#Використовуйте метод copy() для створення копій змінних об'єктів, якщо не хочете змінювати оригінал.

def modify_list(lst: list) -> None:
    lst = lst.copy()
    lst.append(4)
    return lst

my_list = [1, 2, 3]
new_list = modify_list(my_list)
print(my_list)  # виведе: [1, 2, 3]
print(new_list) # виведе: [1, 2, 3, 4]

#Тут список my_list після виконання функції modify_list вже не зазнає змін.
# Це корисно, коли ви хочете змінити список всередині функції, але не хочете змінювати оригінальний список поза функцією. Використати змінені об'єкти можна за допомогою return, якщо потрібно повернути змінений об'єкт з функції.

"""
приклад. Уявімо, що перед нами стоїть задача: конвертувати кожен символ у рядку в його відповідний код ASCII. Це класична задача, що демонструє взаємодію з рядками в Python та їх обробку.
Для отримання числового коду символу ми будемо використовувати вбудовану функцію ord(). Ця функція приймає один символ і повертає його код ASCII. Наприклад, ord('A') повертає 65, оскільки 65 — це код ASCII для символу 'A'.

Рядки в Python — це ітеруємі об'єкти, що означає, що ми можемо пройтися по кожному символу рядка, використовуючи цикл for. Це ідеально підходить для нашої задачі, адже нам потрібно опрацювати кожен символ окремо.
"""

def string_to_codes(string: str) -> dict:
    # Ініціалізація словника для зберігання кодів
    codes = {}
    # Перебір кожного символу в рядку
    for ch in string:
        # Перевірка, чи символ вже є в словнику
        if ch not in codes:
            # Додавання пари символ-код в словник
            codes[ch] = ord(ch)
    return codes

#Ми створюємо пустий словник codes, де будемо зберігати наші пари символ-код. Далі за допомогою циклу for ми ітеруємося по кожному символу ch у вхідному рядку string. В середині циклу перевіряємо кожен символ рядка, чи вже присутній він у словнику? Якщо ні, використовуємо вбудовану функцію ord(ch) для отримання коду ASCII цього символу та додаємо цю пару до словника codes. Після завершення циклу повертаємо словник codes.
# Після виклику функції string_to_codes із рядком "Hello world!", отримуємо словник, де кожен унікальний символ рядка відображений на його числовий код ASCII.

result = string_to_codes("Hello world!")
print(result)
# Виведе: {'H': 72, 'e': 101, 'l': 108, 'o': 111, ' ': 32, 'w': 119, 'r': 114, 'd': 100, '!': 33}

"""
Області видимості (LEGB)

Область видимості — це область у програмі (коді), в межах якої ви можете звернутися за ім'ям до вмісту змінної. Ці області видимості діляться на чотири рівні в порядку пошуку імен змінних, та відомі як LEGB-правило:

L - Local (Локальна): Це внутрішній рівень, де ім'я визначено всередині функції або блоку коду.
E - Enclosing (Охоплювана): Це область видимості, яка охоплює локальну область видимості. Якщо функція знаходиться всередині іншої функції, імена, визначені в охоплюваній функції, будуть доступні для внутрішньої функції.
G - Global (Глобальна): Це область видимості на рівні модуля або сценарію. Змінні, визначені на цьому рівні, доступні у всьому модулі.
B - Built-in (Вбудована): Це самий зовнішній рівень, який містить імена, вбудовані в Python. Наприклад розглянуті нами вбудовані функції, len, range тощо.

"""

#Local variable
def local_scope():
    local_var = "I am a local variable"
    print(local_var)
local_scope()  # Виведе: I am a local variable
# print(local_var)  # Це викличе помилку NameError, оскільки local_var не визначена поза функцією.

#Enclosing variable
def outer_function():
    enclosing_var = "I am an enclosing variable"
    def inner_function():
        print(enclosing_var)  # Виведе: I am an enclosing variable
    inner_function()
outer_function() # Виведе: I am an enclosing variable
# print(enclosing_var)  # Це викличе помилку NameError, оскільки enclosing_var не визначена поза outer_function.

#Global variable
global_var = "I am a global variable"
def global_scope():
    print(global_var)  # Виведе: I am a global variable
global_scope()  # Виведе: I am a global variable
# print(global_var)  # Виведе: I am a global variable - глобальна змінна доступна як всередині функції, так і поза нею.

"""
Ключові аргументи функції

Значеннями за замовчуванням можуть бути забезпечені тільки параметри, що знаходяться у кінці списку параметрів. Таким чином, у списку параметрів функції параметр зі значенням за замовчуванням не може передувати параметру без значення за замовчуванням. Це пов'язано з тим, що значення надаються параметрам відповідно до їх положення. Наприклад, def func(a, b=5) — допустимо, а def func(a=5, b) – не допустимо та призведе до помилки в коді.

"""
def real_cost(base: int, discount: float = 0) -> float:
    return base * (1 - discount)

price_bread = 15
price_butter = 50
price_sugar = 60

current_price_bread = real_cost(price_bread)
current_price_butter = real_cost(price_butter, 0.05)
current_price_sugar = real_cost(price_sugar, 0.07)
print(current_price_bread)  # Виведе: 15.0
print(current_price_butter)  # Виведе: 47.5
print(current_price_sugar)  # Виведе: 55.8

# Функція real_cost показує, як можна використовувати функції та параметри за замовчуванням для обрахунку цін зі знижками. Це приклад того, як прості програмувальні концепції можуть бути застосовані для вирішення реальних бізнес-задач.
