def first(size, *args):
    for i in args:
        size += 1
    return size

print(first(5, "first", "second", "third"))
print(first(1, "Alex", "Boris"))

def second(size, **kwargs):
    size += len(kwargs)
    return size
print(second(3, comment_one="first", comment_two="second", comment_third="third"))


# Ми проводимо розіграш призів серед перших 50 підписників ютуб-каналу. Ми маємо 7 призів для розіграшу. Може виникнути питання, скільки різних списків переможців ми можемо отримати під час розіграшу? Для цього ми будемо використовувати формулу сполучень без повторень

#Cnk = n! / ((n - k)! · k!)

# де n — це загальна кількість людей (випадків), а k — кількість людей, які отримали призи.

# Напишіть функцію number_of_groups, яка приймає параметри n та k, і за допомогою функції factorial повертає нам скільки різних списків переможців ми можемо отримати при розіграші

# Задачі:

# Створіть функцію number_of_groups, яка приймає два аргументи: n - загальна кількість людей та k - кількість переможців.
# У функції number_of_groups, використовуйте функцію factorial для обчислення факторіалів відповідно до формули сполучень: Cnk = n! / ((n - k)! · k!).
# Обчислення здійснюється шляхом виклику функції factorial для отримання факторіалів n, n - k та k.
# Поверніть результат цього обчислення.

# Очікуваний результат:

# Функція number_of_groups повертає кількість можливих різних списків переможців.
# Зверніть увагу на те, які великі значення ми отримуємо для факторіала. Рекурсивні висловлювання треба завжди застосовувати з обережністю при обчисленнях, щоб не отримати переповнення пам'яті.

def factorial(n):
    if n == 0 or n == 1:
        return 1
    else:
        return n * factorial(n - 1)
def number_of_groups(n, k):
    if k > n:
        return 0  # Якщо кількість переможців більша за загальну кількість людей, повертаємо 0
    return factorial(n) // (factorial(n - k) * factorial(k))